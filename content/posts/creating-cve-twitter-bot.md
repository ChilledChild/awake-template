---
title: Creating CVE Twitter Bot
subtitle: A little code goes a long way
category:
  - Projects
author: Danny Child
date: 2021-02-07T20:00:00.000Z
featureImage: /uploads/phillip-glickman-2umo15jszkm-unsplash.jpg
---
CVE A Day is a Twitter bot that tweets a random CVE ID every day. Included in the tweet is the CVE description and a link to view additional details of the CVE. This is runs on a Raspberry Pi 2 model B where I first learned to use Linux in 2015. I made this so I could improve my programming abilities, become more familiar with a language specific nuance, and provide a platform to the public to learn about historical and current CVEs.

My initial idea was to tweet a random CVE ID. I knew that I could use cve.mitre.org to get the CVE ID by a random link, though I was not sure which language to use. When reading articles on making a twitter bot, I realized I first needed to figure out what to use to automate my tweets. Searching online to see what twitter accounts were using to automate their tweets and responses, TweePy stood out the most. Updates looked relatively recent and the creator had an active discord server. Being written in Python, I would already have some familiarity with some of Python’s language organization. However, this project required more than the 10 lines of code I would expect from a small hotkey script.

I considered creating a cloud droplet to host my code, until I saw the hosting cost and capability was beyond what was needed. Hosting this locally would also let me use the PI for other projects and not have to worry about sizing or surprise costs.

After becoming generally familiar with TweePy API commands, I literally drew out the logic for getting my data and creating the tweet. I knew that each link contained the CVE ID, so generating a link would be consistent. I could generate a random ID that followed the pattern of “CVE”, a number between 1999 and 2020, followed by 4 random digits.

`cve_id = #old python code goes here#`

The random ID function was my next hurdle, until I realized that the last section of the ID can extend beyond 4 numbers. I had the option to check if a link was valid by checking the HTTP response code, or I could compare the generated ID to an already existing list of CVEs. I went with the latter, as mitre maintains list of CVEs in a csv file anyone can download. This list also contains the CVE description, and other values, so this worked out well. I knew that reading the file and creating the tweet would be the most difficult part, so I saved it for later.
For the sake of organization and avoiding redundancy, I created multiple snippets of code that had a specific purpose, each as their own function. If my code failed, isolating errors would be easier in the long run. At the same time, I placed logging functions at every significant decision, which would be recorded in a local text file.

`timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]`
`logger = open('history_log.txt', 'a', encoding='utf-8')`
`tweeted = open('tweeted_cve.txt', 'a', encoding='utf-8')`

I learned that the library “csv” would allow my code to read the csv file and get the CVE ID and the description in a randomly given row. To ensure that a CVE would never be tweeted twice, I compared the currently obtained CVE to a list of previously tweeted CVEs. Afterwards, the CVE description is checked to see if the CVE ID was reserved or rejected. Assuming the CVE passed these checks, the CVE, description, and external link would be put together (the link placed in a second tweet) and a tweet would be made! This would be perfect; except I had not accounted for the maximum tweet length, and the API was throwing errors with any attempt I made to use it.

I was at a standstill.

I reached out to my friends Spencer and Jordan. They taught me that strings in Python are immutable and cannot be modified in place. This meant that text cannot be inserted in the middle of a string. To resolve this, we took the CVE ID and description, and iterated through each character until 280 characters were reached, while accounting for additional text. The text was put into an array for ease of access. Interestingly, it is common practice to skip the first index in an array. To solve for the API, the strings had to be organized as objects so that the object (tweet) would be tweeted. If a string is put in place where an object belongs, it will be incorrectly handled due to the data type.

I decided that the OS should handle running the python script, as letting a single script run for a long time can eventually lead to errors if not handled properly.
Besides the final product, what did I learn and gain from this?

* How to better utilize strings with arrays
* Data types matter to the API
* Logging is super useful
* Offering food is a great way to get help

Having a lunch is a great way to network with an industry contact. Since lockdown, many who develop and create IT related content will post their ko-fi or Patreon account while offering their expertise. Beit a question about an industry practice, next career steps, or single technical question, many are willing to work with those who earnestly listen and support a community.